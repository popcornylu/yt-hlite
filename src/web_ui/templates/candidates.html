{% extends "base.html" %}

{% block title %}TT Highlights - Candidates{% endblock %}

{% block content %}
<div class="page-header">
    <div class="header-left">
        <h1>Rally Candidates</h1>
        <p>Keyboard: <kbd>←</kbd><kbd>→</kbd> nav, <kbd>↑</kbd><kbd>↓</kbd> speed, <kbd>1-5</kbd> rate, <kbd>r</kbd> replay, <kbd>{ }</kbd> ±1f</p>
    </div>
    <div class="header-right">
        <button id="analyze-btn" class="btn btn-primary" onclick="startAnalysis()">
            Start Analysis
        </button>
    </div>
</div>

<!-- Analysis Status -->
<div id="analysis-status" class="card hidden">
    <div class="status-panel">
        <div class="spinner"></div>
        <span id="status-text">Analyzing video...</span>
    </div>
</div>

<!-- Video Info (shown after analysis) -->
<div id="video-info" class="card hidden">
    <div class="info-grid">
        <div class="info-item">
            <span class="info-label">Duration</span>
            <span class="info-value" id="duration-value">--</span>
        </div>
        <div class="info-item">
            <span class="info-label">Resolution</span>
            <span class="info-value" id="resolution-value">--</span>
        </div>
        <div class="info-item">
            <span class="info-label">Ball Hits</span>
            <span class="info-value" id="hits-value">--</span>
        </div>
        <div class="info-item">
            <span class="info-label">Rallies Found</span>
            <span class="info-value" id="rallies-value">--</span>
        </div>
    </div>
</div>

<!-- Main Layout with Sidebar -->
<div class="main-layout">
    <!-- Main Content -->
    <div class="main-content">
        <!-- Timeline Section -->
        <div id="timeline-section" class="card" style="overflow: visible;">
            <div class="card-header">
                <h2>Timeline</h2>
                <div class="timeline-header-controls">
                    <div class="zoom-controls">
                        <button class="btn btn-icon" onclick="zoomOut()" title="Zoom Out">-</button>
                        <span id="zoom-level">1x</span>
                        <button class="btn btn-icon" onclick="zoomIn()" title="Zoom In">+</button>
                    </div>
                    <div class="legend">
                        <span class="legend-item"><span class="legend-color keep"></span> Keep</span>
                        <span class="legend-item"><span class="legend-color rejected"></span> Rejected</span>
                        <span class="legend-item"><span class="legend-color current"></span> Current</span>
                    </div>
                </div>
            </div>
            <div class="timeline-scroll-container" id="timeline-scroll">
                <div class="timeline-content" id="timeline-content">
                    <div id="waveform" class="waveform"></div>
                    <div class="timeline-wrapper">
                        <div id="timeline" class="timeline-bar">
                            <!-- Segments populated by JS -->
                        </div>
                        <div id="playhead" class="playhead">
                            <div class="playhead-handle"></div>
                        </div>
                    </div>
                    <div id="time-labels" class="time-labels"></div>
                </div>
            </div>
        </div>

        <!-- Video Player -->
        <div class="card">
            <div class="video-section">
                <video id="main-video" controls>
                    <source src="/video" type="video/mp4">
                </video>
                <div class="current-rally-info">
                    <h3 id="current-rally-title">Select a rally</h3>
                    <div class="rally-meta">
                        <span id="current-rally-time">--:-- - --:--</span>
                        <span id="current-rally-hits">-- hits</span>
                        <span id="current-rally-duration">--s</span>
                    </div>
                    <div class="video-position">
                        <span id="current-position">0.00s</span>
                        <span id="playback-speed" class="playback-speed">1.0x</span>
                    </div>
                    <div class="rating-display" id="current-rating">
                        <span class="star" data-rating="1">★</span>
                        <span class="star" data-rating="2">★</span>
                        <span class="star" data-rating="3">★</span>
                        <span class="star" data-rating="4">★</span>
                        <span class="star" data-rating="5">★</span>
                    </div>
                    <div class="action-buttons">
                        <button class="btn btn-success" id="btn-good" onclick="markGood()">
                            <kbd>↑</kbd> Good
                        </button>
                        <button class="btn btn-danger" id="btn-bad" onclick="markBad()">
                            <kbd>↓</kbd> Bad
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Stats -->
        <div class="card">
            <div class="stats-row">
                <div class="stat-item">
                    <span class="stat-value" id="stat-total">0</span>
                    <span class="stat-label">Total</span>
                </div>
                <div class="stat-item good">
                    <span class="stat-value" id="stat-keep">0</span>
                    <span class="stat-label">Keep</span>
                </div>
                <div class="stat-item bad">
                    <span class="stat-value" id="stat-rejected">0</span>
                    <span class="stat-label">Rejected</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="stat-pending">0</span>
                    <span class="stat-label">Pending</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="stat-duration">0:00</span>
                    <span class="stat-label">Keep Duration</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Sidebar Toggle Button -->
    <button class="sidebar-toggle" onclick="toggleSidebar()" title="Toggle Rally List">
        <span class="toggle-icon">☰</span>
    </button>

    <!-- Sidebar - Rally List -->
    <div class="sidebar hidden" id="sidebar">
        <div class="sidebar-header">
            <h3>All Rallies</h3>
            <div class="sidebar-header-actions">
                <button class="btn btn-small btn-secondary" onclick="addMissedRally()">+ Add</button>
                <button class="btn btn-small btn-icon" onclick="toggleSidebar()" title="Close">✕</button>
            </div>
        </div>
        <div class="sidebar-controls">
            <label class="toggle-label">
                <input type="checkbox" id="hide-rejected" onchange="renderList()">
                Hide rejected
            </label>
        </div>
        <div id="rally-list" class="rally-list">
            <!-- Populated by JS -->
        </div>
    </div>
</div>

<!-- Keyboard Shortcuts Help -->
<div class="shortcuts-help">
    <h4>Keyboard Shortcuts</h4>
    <div class="shortcuts-grid">
        <div><kbd>←</kbd> <kbd>→</kbd></div><div>Previous / Next rally</div>
        <div><kbd>↑</kbd> <kbd>↓</kbd></div><div>Speed +0.1x / -0.1x</div>
        <div><kbd>1</kbd>-<kbd>5</kbd></div><div>Rate & Next (1-3=bad, 4-5=good)</div>
        <div><kbd>Space</kbd></div><div>Play / Pause</div>
        <div><kbd>[</kbd> <kbd>]</kbd></div><div>Seek to start / end</div>
        <div><kbd>{</kbd> <kbd>}</kbd></div><div>Boundary -1f / +1f</div>
        <div><kbd>⌘</kbd><kbd>[</kbd> <kbd>⌘</kbd><kbd>]</kbd></div><div>Set start / end here</div>
        <div><kbd>r</kbd></div><div>Replay rally</div>
        <div><kbd>=</kbd></div><div>Zoom reset (1x)</div>
        <div><kbd>⌘</kbd><kbd>=</kbd> <kbd>⌘</kbd><kbd>-</kbd></div><div>Zoom in / out</div>
        <div><kbd>Esc</kbd></div><div>Deselect rally</div>
    </div>
</div>

<div class="sticky-footer">
    <div class="footer-info">
        <span id="footer-keep-count">0</span> rallies to keep
        (<span id="footer-duration">0:00</span>)
    </div>
    <a href="{{ url_for('review') }}" class="btn btn-primary btn-large">
        Continue to Review →
    </a>
</div>

<!-- Add Rally Modal -->
<div id="add-rally-modal" class="modal hidden">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Add Missed Rally</h3>
            <button class="btn-close" onclick="closeAddModal()">×</button>
        </div>
        <div class="modal-body">
            <p>Mark the start and end times of a rally the system missed.</p>
            <div class="form-group">
                <label>Start Time (seconds)</label>
                <input type="number" id="new-start" step="0.1" min="0" placeholder="e.g., 45.5">
            </div>
            <div class="form-group">
                <label>End Time (seconds)</label>
                <input type="number" id="new-end" step="0.1" min="0" placeholder="e.g., 58.2">
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeAddModal()">Cancel</button>
            <button class="btn btn-primary" onclick="submitNewRally()">Add Rally</button>
        </div>
    </div>
</div>

<style>
/* Page Header */
.page-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
}

.header-left p {
    margin: 0.5rem 0 0 0;
    color: #6c757d;
}

.header-right {
    flex-shrink: 0;
}

/* Main Layout */
.main-layout {
    display: block;
}

.main-content {
    min-width: 0;
}

/* Sidebar Toggle Button */
.sidebar-toggle {
    position: fixed;
    top: 80px;
    right: 0;
    z-index: 200;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 8px 0 0 8px;
    padding: 0.75rem 0.5rem;
    cursor: pointer;
    box-shadow: -2px 2px 8px rgba(0,0,0,0.15);
    transition: transform 0.3s ease;
}

.sidebar-toggle:hover {
    background: #0056b3;
}

.sidebar-toggle .toggle-icon {
    font-size: 1.25rem;
}

.sidebar-toggle.sidebar-open {
    transform: translateX(-280px);
}

/* Sidebar */
.sidebar {
    position: fixed;
    top: 60px;
    right: 0;
    width: 280px;
    height: calc(100vh - 60px);
    background: white;
    box-shadow: -4px 0 12px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    z-index: 150;
    transform: translateX(0);
    transition: transform 0.3s ease;
}

.sidebar.hidden {
    transform: translateX(100%);
}

.sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    border-bottom: 1px solid #e9ecef;
}

.sidebar-header h3 {
    margin: 0;
    font-size: 1rem;
}

.sidebar-header-actions {
    display: flex;
    gap: 0.5rem;
    align-items: center;
}

.sidebar-controls {
    padding: 0.5rem 1rem;
    border-bottom: 1px solid #e9ecef;
    background: #f8f9fa;
}

.btn-small {
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
}

/* Analysis Status */
.status-panel {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
}

.spinner {
    width: 24px;
    height: 24px;
    border: 3px solid #e9ecef;
    border-top-color: #007bff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Video Info */
.info-grid {
    display: flex;
    justify-content: space-around;
    text-align: center;
    padding: 0.5rem 0;
}

.info-item {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.info-label {
    font-size: 0.75rem;
    color: #6c757d;
}

.info-value {
    font-size: 1.25rem;
    font-weight: 600;
}

/* Timeline */
.card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.timeline-header-controls {
    display: flex;
    align-items: center;
    gap: 1.5rem;
}

.zoom-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.zoom-controls .btn-icon {
    width: 28px;
    height: 28px;
    padding: 0;
    font-size: 1rem;
    font-weight: bold;
}

#zoom-level {
    min-width: 2rem;
    text-align: center;
    font-size: 0.875rem;
    color: #6c757d;
}

.timeline-scroll-container {
    overflow-x: auto;
    overflow-y: visible;
    padding: 1.5rem 0 0.5rem 0;
}

.timeline-content {
    min-width: 100%;
    position: relative;
    transition: width 0.2s ease;
    overflow: visible;
}

.waveform {
    height: 60px;
    background: #f8f9fa;
    border-radius: 4px 4px 0 0;
    overflow: hidden;
}

.timeline-wrapper {
    position: relative;
    padding-top: 20px;
}

.timeline-bar {
    height: 50px;
    background: #e9ecef;
    border-radius: 0 0 4px 4px;
    position: relative;
    cursor: pointer;
    overflow: visible;
}

.timeline-segment {
    position: absolute;
    height: 100%;
    border-radius: 2px;
    transition: opacity 0.2s, transform 0.2s;
    cursor: pointer;
}

.timeline-segment.keep {
    background: #28a745;
    opacity: 0.7;
}

.timeline-segment.rejected {
    background: #dc3545;
    opacity: 0.5;
}

.timeline-segment.pending {
    background: #6c757d;
    opacity: 0.5;
}

.timeline-segment.current {
    opacity: 1;
    box-shadow: 0 0 0 3px #ffc107;
    z-index: 10;
}

.timeline-segment:hover {
    opacity: 1;
    transform: scaleY(1.1);
}

/* Drag Handles */
.drag-handle {
    position: absolute;
    top: -4px;
    bottom: -4px;
    width: 12px;
    background: #ffc107;
    cursor: ew-resize;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 20;
    border-radius: 2px;
}

.drag-handle::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 4px;
    height: 20px;
    background: repeating-linear-gradient(
        to bottom,
        #333 0px,
        #333 2px,
        transparent 2px,
        transparent 4px
    );
}

.drag-handle.left {
    left: -6px;
}

.drag-handle.right {
    right: -6px;
}

.timeline-segment.current .drag-handle,
.timeline-segment:hover .drag-handle {
    opacity: 1;
}

.drag-handle:hover {
    background: #e0a800;
}

.timeline-segment.dragging {
    opacity: 0.9;
    z-index: 15;
}

/* Playhead - current position indicator */
.playhead {
    position: absolute;
    top: 20px;
    height: 50px;
    width: 3px;
    background: #ff0000;
    z-index: 100;
    cursor: ew-resize;
    left: 0;
    pointer-events: auto;
}

.playhead-handle {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translate(-50%, -100%);
    width: 18px;
    height: 18px;
    background: #ff0000;
    border-radius: 50%;
    border: 3px solid #fff;
    box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    cursor: ew-resize;
    z-index: 101;
}

.playhead-handle::after {
    content: '';
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 5px solid #ff0000;
}

.playhead:hover .playhead-handle,
.playhead.dragging .playhead-handle {
    background: #cc0000;
    transform: translate(-50%, -100%) scale(1.15);
}

.playhead.dragging {
    transition: none;
}

.time-labels {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    color: #6c757d;
    margin-top: 0.25rem;
    padding: 0 2px;
}

.legend {
    display: flex;
    gap: 1rem;
    font-size: 0.875rem;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 0.25rem;
}

.legend-color {
    width: 16px;
    height: 16px;
    border-radius: 2px;
}

.legend-color.keep { background: #28a745; }
.legend-color.rejected { background: #dc3545; }
.legend-color.current { background: #ffc107; }

/* Video Section */
.video-section {
    display: grid;
    grid-template-columns: 1fr 240px;
    gap: 1rem;
}

.video-section video {
    width: 100%;
    background: #000;
    border-radius: 8px;
}

.current-rally-info {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.current-rally-info h3 {
    margin: 0;
    font-size: 1.25rem;
}

.rally-meta {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    color: #6c757d;
    font-size: 0.875rem;
}

.video-position {
    font-family: monospace;
    font-size: 1.25rem;
    font-weight: 600;
    color: #007bff;
    background: #f8f9fa;
    padding: 0.5rem 0.75rem;
    border-radius: 4px;
    text-align: center;
    letter-spacing: -0.5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.5rem;
}

.playback-speed {
    font-size: 0.9rem;
    color: #6c757d;
    background: #e9ecef;
    padding: 0.2rem 0.4rem;
    border-radius: 3px;
}

.rating-display {
    display: flex;
    gap: 0.25rem;
    font-size: 2rem;
}

.rating-display .star {
    color: #dee2e6;
    cursor: pointer;
    transition: color 0.2s;
}

.rating-display .star:hover,
.rating-display .star.active {
    color: #ffc107;
}

.rating-display .star.bad {
    color: #dc3545;
}

.rating-display .star.good {
    color: #28a745;
}

.action-buttons {
    display: flex;
    gap: 0.5rem;
}

.action-buttons .btn {
    flex: 1;
    padding: 0.75rem;
    font-size: 1rem;
}

.action-buttons kbd {
    background: rgba(255,255,255,0.2);
    padding: 0.125rem 0.375rem;
    border-radius: 3px;
    margin-right: 0.25rem;
}

/* Stats */
.stats-row {
    display: flex;
    justify-content: space-around;
    text-align: center;
}

.stat-item {
    padding: 0.5rem 1rem;
}

.stat-value {
    display: block;
    font-size: 1.5rem;
    font-weight: 600;
}

.stat-label {
    font-size: 0.75rem;
    color: #6c757d;
}

.stat-item.good .stat-value { color: #28a745; }
.stat-item.bad .stat-value { color: #dc3545; }

/* Rally List */
.list-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.rally-list {
    display: flex;
    flex-direction: column;
    gap: 2px;
    overflow-y: auto;
    flex: 1;
    padding: 0.5rem;
}

.rally-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background: #f8f9fa;
    border-radius: 4px;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.15s;
    font-size: 0.8rem;
}

.rally-item:hover {
    background: #e9ecef;
}

.rally-item.current {
    border-color: #ffc107;
    background: #fff3cd;
}

.rally-item.keep {
    border-left: 3px solid #28a745;
}

.rally-item.rejected {
    border-left: 3px solid #dc3545;
    opacity: 0.5;
}

.rally-item.rejected.hide {
    display: none;
}

.rally-rank {
    font-weight: 600;
    color: #6c757d;
    min-width: 28px;
}

.rally-time {
    flex: 1;
    font-size: 0.75rem;
}

.rally-stats {
    display: none;
}

.rally-rating {
    font-size: 0.7rem;
    color: #ffc107;
}

.rally-status {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.65rem;
    color: white;
    flex-shrink: 0;
}

.rally-status.keep { background: #28a745; }
.rally-status.rejected { background: #dc3545; }

/* Shortcuts Help */
.shortcuts-help {
    position: fixed;
    bottom: 80px;
    right: 20px;
    background: white;
    padding: 0.75rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    font-size: 0.7rem;
    opacity: 0.85;
    max-width: 200px;
}

.shortcuts-help h4 {
    margin: 0 0 0.5rem 0;
    font-size: 0.875rem;
}

.shortcuts-grid {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 0.25rem 1rem;
}

.shortcuts-grid kbd {
    background: #e9ecef;
    padding: 0.125rem 0.375rem;
    border-radius: 3px;
    font-size: 0.7rem;
}

/* Footer */
.sticky-footer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: white;
    padding: 1rem 2rem;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 100;
}

.toggle-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
}

/* Modal */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal.hidden {
    display: none;
}

.modal-content {
    background: white;
    border-radius: 8px;
    max-width: 500px;
    width: 90%;
    max-height: 90vh;
    overflow-y: auto;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #dee2e6;
}

.modal-header h3 {
    margin: 0;
}

.btn-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    line-height: 1;
    color: #6c757d;
}

.modal-body {
    padding: 1.5rem;
}

.modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
    padding: 1rem 1.5rem;
    border-top: 1px solid #dee2e6;
}

.form-group {
    margin-bottom: 1rem;
}

.form-group label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
}

.form-group input {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 1rem;
}

/* Responsive */
@media (max-width: 1100px) {
    .sidebar {
        width: 260px;
    }

    .sidebar-toggle.sidebar-open {
        transform: translateX(-260px);
    }
}

@media (max-width: 900px) {
    .video-section {
        grid-template-columns: 1fr;
    }

    .shortcuts-help {
        display: none;
    }

    .page-header {
        flex-direction: column;
        gap: 1rem;
    }
}
</style>
{% endblock %}

{% block scripts %}
<script>
let rallies = [];
let currentIndex = -1;
let videoDuration = 0;
let videoFps = 30; // Will be set from API
let totalFrames = 0;
let zoomLevel = 1;
let isDragging = false;
window.pausedAtBoundary = false;
let dragHandle = null;
let dragRallyIndex = -1;
let dragStartX = 0;
let dragStartFrame = 0;
let analysisComplete = false;

// Frame <-> Time conversion helpers
function frameToTime(frame) {
    return frame / videoFps;
}

function timeToFrame(time) {
    return Math.round(time * videoFps);
}

const video = document.getElementById('main-video');

document.addEventListener('DOMContentLoaded', async () => {
    await checkExistingAnalysis();
    setupKeyboardShortcuts();
    setupVideoEvents();
    setupRatingClicks();
});

async function checkExistingAnalysis() {
    // Check if rallies already exist (analysis was done previously)
    try {
        const response = await fetch('/api/rallies');
        const data = await response.json();
        if (data.rallies && data.rallies.length > 0) {
            analysisComplete = true;
            rallies = data.rallies;
            rallies.sort((a, b) => a.start_time - b.start_time);

            // Get fps from first rally (all rallies have same fps)
            if (rallies[0].fps) {
                videoFps = rallies[0].fps;
            }

            // Hide analyze button, show data
            document.getElementById('analyze-btn').style.display = 'none';

            // Load volume data for waveform
            await loadVolumeData();

            // Setup video duration
            video.onloadedmetadata = () => {
                videoDuration = video.duration;
                renderTimeline();
            };

            renderTimeline();
            renderList();
            updateStats();

            // Auto-select first rally
            if (rallies.length > 0) {
                selectRally(0);
            }
        }
    } catch (e) {
        // No existing analysis, show analyze button
    }
}

async function startAnalysis() {
    const btn = document.getElementById('analyze-btn');
    const statusDiv = document.getElementById('analysis-status');
    const statusText = document.getElementById('status-text');

    btn.disabled = true;
    statusDiv.classList.remove('hidden');

    try {
        statusText.textContent = 'Extracting audio and analyzing...';

        const response = await fetch('/api/analyze', { method: 'POST' });
        const data = await response.json();

        if (!response.ok) throw new Error(data.error);

        // Show video info
        const info = document.getElementById('video-info');
        info.classList.remove('hidden');

        document.getElementById('duration-value').textContent =
            formatTime(data.metadata.duration);
        document.getElementById('resolution-value').textContent =
            `${data.metadata.width}x${data.metadata.height}`;
        document.getElementById('hits-value').textContent = data.num_ball_hits;
        document.getElementById('rallies-value').textContent = data.num_rallies;

        videoDuration = data.metadata.duration;
        videoFps = data.metadata.fps;
        totalFrames = data.metadata.frame_count;

        // Load volume data and rallies
        statusText.textContent = 'Loading visualization...';
        await loadVolumeData();
        await loadRallies();

        // Hide status, show timeline
        statusDiv.classList.add('hidden');
        btn.style.display = 'none';
        analysisComplete = true;

        // Auto-select first rally
        if (rallies.length > 0) {
            selectRally(0);
        }

    } catch (error) {
        statusText.textContent = 'Error: ' + error.message;
        btn.disabled = false;
    }
}

async function loadVolumeData() {
    try {
        const response = await fetch('/api/volume-data');
        const data = await response.json();

        if (data.times && data.volumes) {
            drawWaveform(data.times, data.volumes);
        }
    } catch (e) {
        // Waveform optional
    }
}

function drawWaveform(times, volumes) {
    const container = document.getElementById('waveform');
    const width = container.clientWidth * zoomLevel;
    const height = 60;

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.setAttribute('preserveAspectRatio', 'none');
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

    let d = `M 0 ${height}`;

    for (let i = 0; i < volumes.length; i++) {
        const x = (i / volumes.length) * width;
        const y = height - (volumes[i] * height * 0.9);
        d += ` L ${x} ${y}`;
    }

    d += ` L ${width} ${height} Z`;

    path.setAttribute('d', d);
    path.setAttribute('fill', 'rgba(74, 144, 226, 0.3)');
    path.setAttribute('stroke', 'rgba(74, 144, 226, 0.5)');
    path.setAttribute('stroke-width', '1');

    svg.appendChild(path);
    container.innerHTML = '';
    container.appendChild(svg);
}

async function loadRallies() {
    const response = await fetch('/api/rallies');
    const data = await response.json();
    rallies = data.rallies;

    // Sort by time (start_time)
    rallies.sort((a, b) => a.start_time - b.start_time);

    // Get video duration
    video.onloadedmetadata = () => {
        videoDuration = video.duration;
        renderTimeline();
    };

    renderTimeline();
    renderList();
    updateStats();
}

function renderTimeline() {
    const timeline = document.getElementById('timeline');
    const labels = document.getElementById('time-labels');
    const content = document.getElementById('timeline-content');
    timeline.innerHTML = '';

    // Always prefer actual video duration - update global and use local
    const duration = video.duration || videoDuration || Math.max(...rallies.map(r => r.end_time), 100);
    videoDuration = duration; // Always sync global with current best value

    // Apply zoom
    content.style.width = `${100 * zoomLevel}%`;

    rallies.forEach((rally, i) => {
        const segment = document.createElement('div');
        segment.className = 'timeline-segment';
        segment.dataset.index = i;

        // Status class
        if (rally.is_highlight === false) {
            segment.classList.add('rejected');
        } else if (rally.is_highlight === true) {
            segment.classList.add('keep');
        } else {
            segment.classList.add('pending');
        }

        if (i === currentIndex) {
            segment.classList.add('current');
        }

        // Use local duration variable for consistency
        const left = (rally.start_time / duration) * 100;
        const width = ((rally.end_time - rally.start_time) / duration) * 100;

        segment.style.left = `${left}%`;
        segment.style.width = `${Math.max(width, 0.5)}%`;
        segment.title = `#${i + 1}: ${formatTime(rally.start_time)} - ${formatTime(rally.end_time)}`;

        // Add drag handles
        const leftHandle = document.createElement('div');
        leftHandle.className = 'drag-handle left';
        leftHandle.dataset.side = 'left';
        leftHandle.dataset.index = i;

        const rightHandle = document.createElement('div');
        rightHandle.className = 'drag-handle right';
        rightHandle.dataset.side = 'right';
        rightHandle.dataset.index = i;

        segment.appendChild(leftHandle);
        segment.appendChild(rightHandle);

        // Click to select (not on handles)
        segment.onclick = (e) => {
            if (!e.target.classList.contains('drag-handle')) {
                selectRally(i);
            }
        };

        // Setup drag handlers
        leftHandle.addEventListener('mousedown', startDrag);
        rightHandle.addEventListener('mousedown', startDrag);

        timeline.appendChild(segment);
    });

    // Time labels
    labels.innerHTML = '';
    const numLabels = Math.max(10, Math.floor(10 * zoomLevel));
    for (let i = 0; i <= numLabels; i++) {
        const label = document.createElement('span');
        label.textContent = formatTime((duration / numLabels) * i);
        labels.appendChild(label);
    }
}

function startDrag(e) {
    e.preventDefault();
    e.stopPropagation();

    const handle = e.target;
    const side = handle.dataset.side;
    const index = parseInt(handle.dataset.index);

    isDragging = true;
    dragHandle = side;
    dragRallyIndex = index;
    dragStartX = e.clientX;

    const rally = rallies[index];
    dragStartFrame = side === 'left' ? rally.start_frame : rally.end_frame;

    // Add dragging class
    handle.closest('.timeline-segment').classList.add('dragging');

    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', endDrag);
}

function onDrag(e) {
    if (!isDragging || dragRallyIndex < 0) return;

    const timeline = document.getElementById('timeline');
    const rect = timeline.getBoundingClientRect();
    const scrollContainer = document.getElementById('timeline-scroll');

    // Calculate position accounting for scroll and zoom
    const totalWidth = rect.width;

    const deltaX = e.clientX - dragStartX;
    const framesPerPixel = (videoDuration * videoFps) / totalWidth;
    const deltaFrames = Math.round(deltaX * framesPerPixel);

    // Calculate new frame position
    let newFrame = dragStartFrame + deltaFrames;
    newFrame = Math.max(0, Math.min(newFrame, Math.round(videoDuration * videoFps)));

    const rally = rallies[dragRallyIndex];
    const minDurationFrames = Math.round(1.0 * videoFps); // Minimum 1 second duration

    if (dragHandle === 'left') {
        // Constrain left handle
        newFrame = Math.min(newFrame, rally.end_frame - minDurationFrames);
        rally.start_frame = newFrame;
        rally.start_time = frameToTime(newFrame);
    } else {
        // Constrain right handle
        newFrame = Math.max(newFrame, rally.start_frame + minDurationFrames);
        rally.end_frame = newFrame;
        rally.end_time = frameToTime(newFrame);
    }

    // Update duration
    rally.duration = rally.end_time - rally.start_time;
    rally.duration_frames = rally.end_frame - rally.start_frame;

    // Update visual
    const segment = document.querySelector(`.timeline-segment[data-index="${dragRallyIndex}"]`);
    if (segment) {
        const left = (rally.start_time / videoDuration) * 100;
        const width = ((rally.end_time - rally.start_time) / videoDuration) * 100;
        segment.style.left = `${left}%`;
        segment.style.width = `${Math.max(width, 0.5)}%`;
        segment.title = `#${dragRallyIndex + 1}: ${formatTime(rally.start_time)} - ${formatTime(rally.end_time)}`;
    }

    // Update current rally display if this is the current rally
    if (dragRallyIndex === currentIndex) {
        document.getElementById('current-rally-time').textContent =
            `${formatTimePrecise(rally.start_time)} - ${formatTimePrecise(rally.end_time)}`;
        document.getElementById('current-rally-duration').textContent = `${rally.duration.toFixed(2)}s`;
    }
}

async function endDrag(e) {
    if (!isDragging) return;

    const segment = document.querySelector(`.timeline-segment[data-index="${dragRallyIndex}"]`);
    if (segment) {
        segment.classList.remove('dragging');
    }

    // Save to server (using frames)
    const rally = rallies[dragRallyIndex];
    try {
        await fetch(`/api/rally/${rally.id}/adjust`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                start_frame: rally.start_frame,
                end_frame: rally.end_frame
            })
        });

        // Re-render list to update times
        renderList();
        updateStats();

    } catch (e) {
        console.error('Failed to save boundary adjustment:', e);
    }

    isDragging = false;
    dragHandle = null;
    dragRallyIndex = -1;

    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', endDrag);
}

function renderList() {
    const list = document.getElementById('rally-list');
    const hideRejected = document.getElementById('hide-rejected').checked;
    list.innerHTML = '';

    rallies.forEach((rally, i) => {
        const item = document.createElement('div');
        item.className = 'rally-item';
        item.dataset.index = i;

        if (i === currentIndex) item.classList.add('current');

        if (rally.is_highlight === false) {
            item.classList.add('rejected');
            if (hideRejected) item.classList.add('hide');
        } else if (rally.is_highlight === true) {
            item.classList.add('keep');
        }

        const ratingStars = rally.user_rating
            ? '★'.repeat(rally.user_rating)
            : '';

        item.innerHTML = `
            <span class="rally-rank">#${i + 1}</span>
            <span class="rally-time">${formatTime(rally.start_time)}</span>
            <span class="rally-rating">${ratingStars}</span>
            ${rally.is_highlight !== null ? `
                <span class="rally-status ${rally.is_highlight ? 'keep' : 'rejected'}">
                    ${rally.is_highlight ? '✓' : '✕'}
                </span>
            ` : ''}
        `;

        item.onclick = () => selectRally(i);
        list.appendChild(item);
    });
}

function deselectRally() {
    currentIndex = -1;

    // Update UI to show no selection
    document.getElementById('current-rally-title').textContent = 'No rally selected';
    document.getElementById('current-rally-time').textContent = '--:-- - --:--';
    document.getElementById('current-rally-hits').textContent = '-- hits';
    document.getElementById('current-rally-duration').textContent = '--s';

    // Clear rating display
    const stars = document.querySelectorAll('.rating-display .star');
    stars.forEach(star => star.classList.remove('active', 'good', 'bad'));

    renderTimeline();
    renderList();
}

function selectRally(index) {
    if (index < 0 || index >= rallies.length) return;

    currentIndex = index;
    window.pausedAtBoundary = false; // Reset boundary flag for new rally
    const rally = rallies[index];

    // Update UI
    document.getElementById('current-rally-title').textContent = `Rally #${index + 1}`;
    document.getElementById('current-rally-time').textContent =
        `${formatTimePrecise(rally.start_time)} - ${formatTimePrecise(rally.end_time)}`;
    document.getElementById('current-rally-hits').textContent = `${rally.hit_count} hits`;
    document.getElementById('current-rally-duration').textContent = `${rally.duration.toFixed(2)}s`;

    // Update rating display
    updateRatingDisplay(rally.user_rating, rally.is_highlight);

    // Seek video (use frame-based calculation, with 0.5s lead-in)
    const startTime = rally.start_frame / videoFps;
    video.currentTime = Math.max(0, startTime - 0.5);
    video.play();

    renderTimeline();
    renderList();

    // Scroll timeline to center on current rally when zoomed
    if (zoomLevel > 1) {
        scrollToRally(index);
    }

    // Scroll list item into view
    const listItem = document.querySelector(`.rally-item[data-index="${index}"]`);
    if (listItem) {
        listItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

function scrollToRally(index) {
    const rally = rallies[index];
    const scrollContainer = document.getElementById('timeline-scroll');
    const content = document.getElementById('timeline-content');

    const rallyCenter = (rally.start_time + rally.end_time) / 2;
    const percent = rallyCenter / videoDuration;
    const contentWidth = content.offsetWidth;
    const containerWidth = scrollContainer.offsetWidth;

    const scrollTarget = (percent * contentWidth) - (containerWidth / 2);
    scrollContainer.scrollTo({
        left: Math.max(0, scrollTarget),
        behavior: 'smooth'
    });
}

function updateRatingDisplay(rating, isHighlight) {
    const stars = document.querySelectorAll('.rating-display .star');
    stars.forEach((star, i) => {
        star.classList.remove('active', 'good', 'bad');
        if (rating && i < rating) {
            star.classList.add('active');
            if (rating <= 3) star.classList.add('bad');
            else star.classList.add('good');
        }
    });
}

function setupRatingClicks() {
    document.querySelectorAll('.rating-display .star').forEach(star => {
        star.onclick = () => {
            const rating = parseInt(star.dataset.rating);
            rateCurrentRally(rating);
        };
    });
}

async function rateCurrentRally(rating) {
    if (currentIndex < 0) return;

    const rally = rallies[currentIndex];
    const isGood = rating >= 4;

    // Update rating
    await fetch(`/api/rally/${rally.id}/rate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ rating })
    });

    // Update highlight status
    await fetch(`/api/rally/${rally.id}/confirm`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ is_highlight: isGood })
    });

    rally.user_rating = rating;
    rally.is_highlight = isGood;

    updateRatingDisplay(rating, isGood);
    renderTimeline();
    renderList();
    updateStats();
}

async function markGood() {
    if (currentIndex < 0) return;

    const rally = rallies[currentIndex];

    await fetch(`/api/rally/${rally.id}/confirm`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ is_highlight: true })
    });

    rally.is_highlight = true;

    renderTimeline();
    renderList();
    updateStats();
}

async function markBad() {
    if (currentIndex < 0) return;

    const rally = rallies[currentIndex];

    await fetch(`/api/rally/${rally.id}/confirm`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ is_highlight: false })
    });

    rally.is_highlight = false;

    renderTimeline();
    renderList();
    updateStats();
}

function goNext() {
    const currentTime = video.currentTime;
    // Find the next rally that starts after current position
    let nextIndex = -1;
    for (let i = 0; i < rallies.length; i++) {
        if (rallies[i].start_time > currentTime + 0.1) {
            nextIndex = i;
            break;
        }
    }
    // If no rally found after current position, stay at last
    if (nextIndex === -1 && rallies.length > 0) {
        nextIndex = rallies.length - 1;
    }
    if (nextIndex >= 0) {
        selectRally(nextIndex);
    }
}

function goPrev() {
    const currentTime = video.currentTime;
    // Find the previous rally that ends before current position
    let prevIndex = -1;
    for (let i = rallies.length - 1; i >= 0; i--) {
        if (rallies[i].end_time < currentTime - 0.1) {
            prevIndex = i;
            break;
        }
        // Also select if we're in the middle of a rally and want to go to its start
        if (rallies[i].start_time < currentTime - 0.5 && rallies[i].end_time >= currentTime) {
            prevIndex = i;
            break;
        }
    }
    // If no rally found before current position, go to first
    if (prevIndex === -1 && rallies.length > 0) {
        prevIndex = 0;
    }
    if (prevIndex >= 0) {
        selectRally(prevIndex);
    }
}

function updateStats() {
    const total = rallies.length;
    const keep = rallies.filter(r => r.is_highlight === true).length;
    const rejected = rallies.filter(r => r.is_highlight === false).length;
    const pending = total - keep - rejected;
    const keepDuration = rallies
        .filter(r => r.is_highlight !== false)
        .reduce((sum, r) => sum + r.duration, 0);

    document.getElementById('stat-total').textContent = total;
    document.getElementById('stat-keep').textContent = keep;
    document.getElementById('stat-rejected').textContent = rejected;
    document.getElementById('stat-pending').textContent = pending;
    document.getElementById('stat-duration').textContent = formatTime(keepDuration);

    document.getElementById('footer-keep-count').textContent = keep + pending;
    document.getElementById('footer-duration').textContent = formatTime(keepDuration);

    // Save to session storage
    const keepIds = rallies.filter(r => r.is_highlight !== false).map(r => r.id);
    sessionStorage.setItem('selectedRallies', JSON.stringify(keepIds));
}

// Zoom functions
const PIXELS_PER_SECOND_AT_MAX_ZOOM = 96; // 1 inch = 96px = 1 second at max zoom

function getMaxZoom() {
    const container = document.getElementById('timeline-scroll');
    const duration = video.duration || videoDuration;
    if (!container || !duration) return 64;
    const containerWidth = container.clientWidth;
    // At max zoom: duration * 96px = total width
    // maxZoom = (duration * 96) / containerWidth
    const maxZoom = (duration * PIXELS_PER_SECOND_AT_MAX_ZOOM) / containerWidth;
    return Math.max(1, maxZoom);
}

function zoomIn() {
    const maxZoom = getMaxZoom();
    // Zoom levels: 1, 2, 4, 8, 16, 32, 64, ...
    zoomLevel = Math.min(zoomLevel * 2, maxZoom);
    applyZoom();
}

function zoomOut() {
    // Zoom levels: ..., 64, 32, 16, 8, 4, 2, 1
    zoomLevel = Math.max(zoomLevel / 2, 1);
    applyZoom();
}

function zoomToMin() {
    zoomLevel = 1;
    applyZoom();
}

function applyZoom() {
    // Display as integer if it's a whole number, otherwise with 1 decimal
    const zoomText = Number.isInteger(zoomLevel) ? `${zoomLevel}x` : `${zoomLevel.toFixed(1)}x`;
    document.getElementById('zoom-level').textContent = zoomText;
    renderTimeline();

    // Re-draw waveform at new zoom level
    loadVolumeData();

    // Scroll to current rally
    if (currentIndex >= 0 && zoomLevel > 1) {
        setTimeout(() => scrollToRally(currentIndex), 50);
    }
}

// Add Missed Rally Modal
function addMissedRally() {
    document.getElementById('add-rally-modal').classList.remove('hidden');
    // Pre-fill with current video time
    document.getElementById('new-start').value = Math.floor(video.currentTime * 10) / 10;
    document.getElementById('new-end').value = Math.floor((video.currentTime + 5) * 10) / 10;
}

function closeAddModal() {
    document.getElementById('add-rally-modal').classList.add('hidden');
}

async function submitNewRally() {
    const startTime = parseFloat(document.getElementById('new-start').value);
    const endTime = parseFloat(document.getElementById('new-end').value);

    if (isNaN(startTime) || isNaN(endTime) || startTime >= endTime) {
        alert('Please enter valid start and end times');
        return;
    }

    // Convert time to frames for the API
    const startFrame = timeToFrame(startTime);
    const endFrame = timeToFrame(endTime);

    const response = await fetch('/api/add-rally', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ start_frame: startFrame, end_frame: endFrame })
    });

    if (response.ok) {
        await loadRallies();
        closeAddModal();
        document.getElementById('new-start').value = '';
        document.getElementById('new-end').value = '';

        // Select the new rally (will be in the list now)
        const newIndex = rallies.findIndex(r =>
            Math.abs(r.start_frame - startFrame) < 2 &&
            Math.abs(r.end_frame - endFrame) < 2
        );
        if (newIndex >= 0) {
            selectRally(newIndex);
        }
    }
}

function setupKeyboardShortcuts() {
    // Use capture phase to get events before video player
    document.addEventListener('keydown', async (e) => {
        // Ignore if typing in text input (but allow checkboxes)
        if ((e.target.tagName === 'INPUT' && e.target.type !== 'checkbox') || e.target.tagName === 'TEXTAREA') return;

        const isMeta = e.metaKey || e.ctrlKey;

        switch (e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                goPrev();
                break;

            case 'ArrowRight':
                e.preventDefault();
                goNext();
                break;

            case 'ArrowUp':
                e.preventDefault();
                increasePlaybackSpeed();
                break;

            case 'ArrowDown':
                e.preventDefault();
                decreasePlaybackSpeed();
                break;

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
                e.preventDefault();
                await rateCurrentRally(parseInt(e.key));
                goNext();
                break;

            case ' ':
                e.preventDefault();
                if (video.paused) video.play();
                else video.pause();
                break;

            case '+':
            case '=':
                e.preventDefault();
                if (isMeta) {
                    zoomIn();
                } else {
                    zoomToMin();
                }
                break;

            case '-':
                e.preventDefault();
                if (isMeta) {
                    zoomOut();
                }
                break;

            case '[':
                e.preventDefault();
                if (isMeta) {
                    // Cmd+[: Set start to current position
                    await setStartToCurrentPosition();
                } else {
                    // [: seek to start of rally
                    seekToBoundary('start');
                }
                break;

            case '{':
                // Shift+[: if at start → start-1f, if at end → end-1f
                e.preventDefault();
                await adjustBoundaryAtCurrentPosition(-1);
                break;

            case ']':
                e.preventDefault();
                if (isMeta) {
                    // Cmd+]: Set end to current position
                    await setEndToCurrentPosition();
                } else {
                    // ]: seek to end of rally
                    seekToBoundary('end');
                }
                break;

            case '}':
                // Shift+]: if at start → start+1f, if at end → end+1f
                e.preventDefault();
                await adjustBoundaryAtCurrentPosition(1);
                break;

            case 'Escape':
                e.preventDefault();
                deselectRally();
                break;

            case 'r':
                // Don't intercept Cmd+r (browser refresh)
                if (!isMeta) {
                    e.preventDefault();
                    replayRally();
                }
                break;
        }
    }, true);  // Use capture phase
}

function seekToBoundary(boundary) {
    if (currentIndex < 0) return;

    const rally = rallies[currentIndex];
    video.pause();

    if (boundary === 'start') {
        // Use frame-based calculation for precision
        video.currentTime = rally.start_frame / videoFps;
    } else {
        video.currentTime = rally.end_frame / videoFps;
    }

    updatePositionDisplay();
}

function replayRally() {
    if (currentIndex < 0) return;

    const rally = rallies[currentIndex];
    window.pausedAtBoundary = false;
    video.currentTime = rally.start_frame / videoFps;
    video.play();
}

function increasePlaybackSpeed() {
    const newRate = Math.min(video.playbackRate + 0.1, 4.0);
    video.playbackRate = Math.round(newRate * 10) / 10; // Round to 1 decimal
    updatePlaybackSpeedDisplay();
}

function decreasePlaybackSpeed() {
    const newRate = Math.max(video.playbackRate - 0.1, 0.1);
    video.playbackRate = Math.round(newRate * 10) / 10; // Round to 1 decimal
    updatePlaybackSpeedDisplay();
}

function updatePlaybackSpeedDisplay() {
    const speedEl = document.getElementById('playback-speed');
    if (speedEl) {
        speedEl.textContent = `${video.playbackRate.toFixed(1)}x`;
    }
}

function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const toggle = document.querySelector('.sidebar-toggle');
    sidebar.classList.toggle('hidden');
    toggle.classList.toggle('sidebar-open');
}

async function setStartToCurrentPosition() {
    if (currentIndex < 0) return;

    const rally = rallies[currentIndex];
    const currentFrame = timeToFrame(video.currentTime);
    const minDurationFrames = Math.round(1.0 * videoFps);

    // Don't let start go past end - minDuration
    if (currentFrame >= rally.end_frame - minDurationFrames) return;

    rally.start_frame = currentFrame;
    rally.start_time = frameToTime(currentFrame);
    rally.duration = rally.end_time - rally.start_time;
    rally.duration_frames = rally.end_frame - rally.start_frame;

    // Update UI
    document.getElementById('current-rally-time').textContent =
        `${formatTimePrecise(rally.start_time)} - ${formatTimePrecise(rally.end_time)}`;
    document.getElementById('current-rally-duration').textContent = `${rally.duration.toFixed(2)}s`;

    renderTimeline();
    renderList();
    updateStats();

    await saveBoundaryAdjustment(rally);
}

async function setEndToCurrentPosition() {
    if (currentIndex < 0) return;

    const rally = rallies[currentIndex];
    const currentFrame = timeToFrame(video.currentTime);
    const minDurationFrames = Math.round(1.0 * videoFps);

    // Don't let end go before start + minDuration
    if (currentFrame <= rally.start_frame + minDurationFrames) return;

    rally.end_frame = currentFrame;
    rally.end_time = frameToTime(currentFrame);
    rally.duration = rally.end_time - rally.start_time;
    rally.duration_frames = rally.end_frame - rally.start_frame;

    // Update UI
    document.getElementById('current-rally-time').textContent =
        `${formatTimePrecise(rally.start_time)} - ${formatTimePrecise(rally.end_time)}`;
    document.getElementById('current-rally-duration').textContent = `${rally.duration.toFixed(2)}s`;

    renderTimeline();
    renderList();
    updateStats();

    await saveBoundaryAdjustment(rally);
}

async function adjustBoundaryAtCurrentPosition(deltaFrames) {
    if (currentIndex < 0) return;

    const rally = rallies[currentIndex];
    const currentFrame = timeToFrame(video.currentTime);
    const startFrame = rally.start_frame;
    const endFrame = rally.end_frame;

    // Check if we're at start or end boundary (within 1 frame tolerance)
    const atStart = Math.abs(currentFrame - startFrame) <= 1;
    const atEnd = Math.abs(currentFrame - endFrame) <= 1;

    if (atStart) {
        await adjustBoundaryByFrames('start', deltaFrames);
    } else if (atEnd) {
        await adjustBoundaryByFrames('end', deltaFrames);
    }
    // Otherwise no-op
}

async function adjustBoundaryByFrames(boundary, deltaFrames) {
    if (currentIndex < 0) return;

    video.pause();

    const rally = rallies[currentIndex];
    const minDurationFrames = Math.round(1.0 * videoFps); // Minimum 1 second
    let jumpToFrame;

    if (boundary === 'start') {
        const newStartFrame = Math.max(0, rally.start_frame + deltaFrames);
        // Don't let start go past end - minDuration
        if (newStartFrame >= rally.end_frame - minDurationFrames) return;
        rally.start_frame = newStartFrame;
        rally.start_time = frameToTime(newStartFrame);
        jumpToFrame = newStartFrame;
    } else {
        const maxFrame = Math.round(videoDuration * videoFps);
        const newEndFrame = Math.min(maxFrame, rally.end_frame + deltaFrames);
        // Don't let end go before start + minDuration
        if (newEndFrame <= rally.start_frame + minDurationFrames) return;
        rally.end_frame = newEndFrame;
        rally.end_time = frameToTime(newEndFrame);
        jumpToFrame = newEndFrame;
    }

    // Jump to the adjusted frame and pause
    video.currentTime = jumpToFrame / videoFps;
    video.pause();

    // Update duration
    rally.duration = rally.end_time - rally.start_time;
    rally.duration_frames = rally.end_frame - rally.start_frame;

    // Update UI immediately
    document.getElementById('current-rally-time').textContent =
        `${formatTimePrecise(rally.start_time)} - ${formatTimePrecise(rally.end_time)}`;
    document.getElementById('current-rally-duration').textContent = `${rally.duration.toFixed(2)}s`;

    renderTimeline();
    renderList();
    updateStats();

    // Save to server
    await saveBoundaryAdjustment(rally);
}

async function saveBoundaryAdjustment(rally) {
    try {
        await fetch(`/api/rally/${rally.id}/adjust`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                start_frame: rally.start_frame,
                end_frame: rally.end_frame
            })
        });
    } catch (e) {
        console.error('Failed to save boundary adjustment:', e);
    }
}

function setupVideoEvents() {
    // Click on timeline bar (not segments) to seek
    document.getElementById('timeline').addEventListener('click', (e) => {
        if (e.target.id !== 'timeline') return;

        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percent = x / rect.width;
        const time = percent * videoDuration;

        // Find closest rally
        let closestIndex = 0;
        let closestDist = Infinity;
        rallies.forEach((rally, i) => {
            const mid = (rally.start_time + rally.end_time) / 2;
            const dist = Math.abs(mid - time);
            if (dist < closestDist) {
                closestDist = dist;
                closestIndex = i;
            }
        });

        selectRally(closestIndex);
    });

    // Update position display during playback
    video.addEventListener('timeupdate', updatePositionDisplay);
    video.addEventListener('seeked', updatePositionDisplay);

    // Pause at rally end boundary, deselect if resumed past it
    video.addEventListener('timeupdate', () => {
        if (currentIndex >= 0 && !video.paused && !window.pausedAtBoundary) {
            const rally = rallies[currentIndex];
            const endTime = rally.end_frame / videoFps;
            // If we've reached the rally end, pause at boundary
            if (video.currentTime >= endTime - 0.05) {
                video.currentTime = endTime;
                video.pause();
                window.pausedAtBoundary = true;
            }
        }
    });

    video.addEventListener('play', () => {
        if (currentIndex >= 0 && window.pausedAtBoundary) {
            const rally = rallies[currentIndex];
            const endTime = rally.end_frame / videoFps;
            // If resuming play while at/past the boundary, deselect and continue
            if (video.currentTime >= endTime - 0.1) {
                deselectRally();
            }
        }
        window.pausedAtBoundary = false;
    });

    // Cmd/Ctrl + scroll to zoom timeline
    const timelineScroll = document.getElementById('timeline-scroll');
    timelineScroll.addEventListener('wheel', (e) => {
        if (e.metaKey || e.ctrlKey) {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        }
    }, { passive: false });

    // Draggable playhead
    setupPlayheadDrag();
}

let isPlayheadDragging = false;

function setupPlayheadDrag() {
    const playhead = document.getElementById('playhead');
    const handle = playhead.querySelector('.playhead-handle');

    // Make both the line and handle draggable
    [playhead, handle].forEach(el => {
        el.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isPlayheadDragging = true;
            playhead.classList.add('dragging');
            video.pause();

            document.addEventListener('mousemove', onPlayheadDrag);
            document.addEventListener('mouseup', endPlayheadDrag);
        });
    });
}

function onPlayheadDrag(e) {
    if (!isPlayheadDragging) return;

    const timeline = document.getElementById('timeline');
    const wrapper = timeline.closest('.timeline-wrapper');
    const rect = wrapper.getBoundingClientRect();

    let x = e.clientX - rect.left;
    x = Math.max(0, Math.min(x, rect.width));

    const percent = x / rect.width;
    const newTime = percent * videoDuration;

    video.currentTime = newTime;
    updatePositionDisplay();
}

function endPlayheadDrag() {
    if (!isPlayheadDragging) return;

    isPlayheadDragging = false;
    const playhead = document.getElementById('playhead');
    playhead.classList.remove('dragging');

    document.removeEventListener('mousemove', onPlayheadDrag);
    document.removeEventListener('mouseup', endPlayheadDrag);
}

function updatePositionDisplay() {
    const positionEl = document.getElementById('current-position');
    positionEl.textContent = formatTimePrecise(video.currentTime);

    // Update playhead position on timeline
    updatePlayheadPosition();

    // Keep playhead in view
    ensurePlayheadVisible();
}

function updatePlayheadPosition() {
    const playhead = document.getElementById('playhead');
    const timeline = document.getElementById('timeline');
    // Always use video.duration directly for accuracy
    const duration = video.duration || videoDuration;
    if (playhead && timeline && duration > 0) {
        const percent = (video.currentTime / duration) * 100;
        playhead.style.left = `${percent}%`;
    }
}

function ensurePlayheadVisible() {
    if (zoomLevel <= 1) return; // No need to scroll at 1x zoom

    const scrollContainer = document.getElementById('timeline-scroll');
    const content = document.getElementById('timeline-content');
    const duration = video.duration || videoDuration;
    if (!scrollContainer || !content || !duration) return;

    const contentWidth = content.offsetWidth;
    const containerWidth = scrollContainer.offsetWidth;
    const scrollLeft = scrollContainer.scrollLeft;

    // Calculate playhead position in pixels
    const playheadPercent = video.currentTime / duration;
    const playheadX = playheadPercent * contentWidth;

    // Visible range
    const visibleLeft = scrollLeft;
    const visibleRight = scrollLeft + containerWidth;

    // Add padding so we scroll before hitting the edge
    const padding = containerWidth * 0.15;

    // Check if playhead is outside visible area (with padding)
    if (playheadX < visibleLeft + padding) {
        // Scroll left to show playhead
        scrollContainer.scrollTo({
            left: Math.max(0, playheadX - padding),
            behavior: 'smooth'
        });
    } else if (playheadX > visibleRight - padding) {
        // Scroll right to show playhead
        scrollContainer.scrollTo({
            left: playheadX - containerWidth + padding,
            behavior: 'smooth'
        });
    }
}

function formatTimePrecise(seconds) {
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const centis = Math.floor((seconds % 1) * 100);
    return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${centis.toString().padStart(2, '0')}s`;
}

function formatTime(seconds) {
    if (seconds === undefined || seconds === null) return '00:00:00.00';
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const centis = Math.floor((seconds % 1) * 100);
    return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${centis.toString().padStart(2, '0')}`;
}
</script>
{% endblock %}
